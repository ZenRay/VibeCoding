//! Run å‘½ä»¤å®ç°
//!
//! æ‰§è¡ŒåŠŸèƒ½å¼€å‘çš„å®Œæ•´æµç¨‹ (7 ä¸ªé˜¶æ®µ)

use std::path::{Path, PathBuf};
use std::sync::Arc;

use ca_core::{
    CliEventHandler, ExecutionEngine, KeywordMatcher, Phase, Repository, StateManager, Status,
};
use ca_pm::{ContextBuilder, PromptConfig, PromptManager};

use crate::config::AppConfig;

/// æœ€å¤§ Fix è¿­ä»£æ¬¡æ•°
const MAX_FIX_ITERATIONS: usize = 3;

/// æ‰§è¡Œ run å‘½ä»¤
#[allow(clippy::too_many_arguments)]
pub async fn execute_run(
    feature_slug: String,
    phase: Option<u8>,
    resume: bool,
    dry_run: bool,
    skip_review: bool,
    skip_test: bool,
    repo: Option<PathBuf>,
    config: &AppConfig,
) -> anyhow::Result<()> {
    println!("ğŸš€ æ‰§è¡ŒåŠŸèƒ½å¼€å‘: {}", feature_slug);
    println!();

    // 1. ç¡®å®šå·¥ä½œç›®å½•
    let repo_path = determine_repo_path(repo, &config.default_repo)?;
    println!("ğŸ“‚ å·¥ä½œç›®å½•: {}", repo_path.display());

    // 2. æ£€æŸ¥ specs ç›®å½•
    let feature_dir = find_feature_dir(&repo_path, &feature_slug)?;
    println!("ğŸ“ Specs ç›®å½•: {}", feature_dir.display());
    println!();

    // 3. åŠ è½½çŠ¶æ€ç®¡ç†
    let mut state_manager = StateManager::new(&feature_slug, &repo_path)?;

    // æ·»åŠ  Status Document Hook
    let specs_dir = repo_path.join("specs");
    let spec_file = feature_dir.join("spec.md");
    let spec_content = if spec_file.exists() {
        std::fs::read_to_string(&spec_file).unwrap_or_default()
    } else {
        String::new()
    };

    let status_hook = Arc::new(ca_core::StatusDocumentHook::new(specs_dir, spec_content));
    state_manager.add_hook(status_hook);

    // 4. æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢å¤
    if resume || state_manager.can_resume() {
        println!("ğŸ”„ æ£€æµ‹åˆ°ä¸­æ–­çš„æ‰§è¡Œï¼Œå‡†å¤‡æ¢å¤...");
        return resume_execution(
            state_manager,
            &repo_path,
            &feature_dir,
            dry_run,
            skip_review,
            skip_test,
            config,
        )
        .await;
    }

    // 5. åˆ›å»º Repository å’Œ Agent
    let repository = Arc::new(Repository::new(&repo_path)?);
    let agent = create_agent(config)?;

    // åˆ›å»º EventHandler
    let event_handler = Box::new(CliEventHandler::new());

    // åˆ›å»º ExecutionEngine
    let mut engine = ExecutionEngine::new(agent, repository.clone())
        .with_event_handler(event_handler);

    // 6. éªŒè¯è¿æ¥
    println!("ğŸ”Œ éªŒè¯ Agent è¿æ¥...");
    if !engine.validate().await? {
        anyhow::bail!("âŒ Agent è¿æ¥éªŒè¯å¤±è´¥");
    }
    println!("âœ… è¿æ¥æˆåŠŸ");
    println!();

    // 7. åˆ›å»º PromptManager
    let prompt_config = PromptConfig {
        template_dir: config.prompt.template_dir.clone(),
        default_template: None,
    };
    let prompt_manager = PromptManager::new(prompt_config)?;

    // 8. ç¡®å®šæ‰§è¡Œé˜¶æ®µ
    let start_phase = phase.unwrap_or(1);
    let end_phase = phase.unwrap_or(7);

    // 9. æ‰§è¡Œå„ä¸ªé˜¶æ®µ
    for phase_num in start_phase..=end_phase {
        println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        println!("Phase {}: {}", phase_num, get_phase_name(phase_num));
        println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        println!();

        // æ ‡è®°é˜¶æ®µå¼€å§‹
        state_manager.start_phase_with_default_name(phase_num)?;

        // è·³è¿‡æŸäº›é˜¶æ®µ
        if skip_review && phase_num == 5 {
            println!("â­ï¸  è·³è¿‡ä»£ç å®¡æŸ¥");
            state_manager.update_phase_status(phase_num, Status::Completed)?;
            continue;
        }

        if skip_test && phase_num == 7 {
            println!("â­ï¸  è·³è¿‡æµ‹è¯•éªŒè¯");
            state_manager.update_phase_status(phase_num, Status::Completed)?;
            continue;
        }

        // æ‰§è¡Œé˜¶æ®µ
        match phase_num {
            1 => {
                execute_observer_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    &feature_dir,
                    &repo_path,
                    dry_run,
                )
                .await?
            }
            2 => {
                execute_planning_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    &feature_dir,
                    &repo_path,
                    dry_run,
                )
                .await?
            }
            3 | 4 => {
                execute_execute_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    &feature_dir,
                    &repo_path,
                    phase_num,
                    dry_run,
                )
                .await?
            }
            5 => {
                execute_review_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    &feature_dir,
                    &repo_path,
                    dry_run,
                )
                .await?
            }
            6 => {
                execute_fix_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    &feature_dir,
                    &repo_path,
                    dry_run,
                )
                .await?
            }
            7 => {
                execute_verification_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    &feature_dir,
                    &repo_path,
                    dry_run,
                )
                .await?
            }
            _ => anyhow::bail!("æ— æ•ˆçš„ phase ç¼–å·: {}", phase_num),
        }

        // æ ‡è®°é˜¶æ®µå®Œæˆ
        state_manager.update_phase_status(phase_num, Status::Completed)?;
        state_manager.save()?;
        println!("âœ… Phase {} å®Œæˆ", phase_num);
        println!();
    }

    // 10. æ‰€æœ‰é˜¶æ®µå®Œæˆ
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("ğŸ‰ åŠŸèƒ½å¼€å‘å®Œæˆ!");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();

    // 11. ç”Ÿæˆ PR
    if !dry_run {
        println!("ğŸ“‹ å‡†å¤‡åˆ›å»º Pull Request...");
        match generate_pr(&feature_slug, &feature_dir, &repo_path).await {
            Ok(pr_url) => {
                println!("âœ… PR å·²åˆ›å»º: {}", pr_url);

                // æ›´æ–°çŠ¶æ€
                if let Ok(pr_number) = extract_pr_number(&pr_url) {
                    state_manager.set_pr_info(pr_url.clone(), pr_number)?;
                    state_manager.save()?;
                }
            }
            Err(e) => {
                println!("âš ï¸  PR åˆ›å»ºå¤±è´¥: {}", e);
                println!("   ä½ å¯ä»¥æ‰‹åŠ¨åˆ›å»º PR");
            }
        }
    }

    Ok(())
}

/// Phase 1: Observer - é¡¹ç›®åˆ†æ
async fn execute_observer_phase(
    engine: &mut ExecutionEngine,
    state_manager: &mut StateManager,
    pm: &PromptManager,
    feature_dir: &Path,
    repo_path: &Path,
    dry_run: bool,
) -> anyhow::Result<()> {
    println!("ğŸ“Š Phase 1: Observer - é¡¹ç›®åˆ†æ");

    // 1. åŠ è½½æ¨¡æ¿
    let task_dir = PathBuf::from("crates/ca-pm/templates/run/phase1_observer");
    let task_template = pm.load_task_dir(&task_dir)?;

    // 2. æ„å»ºä¸Šä¸‹æ–‡
    let spec_content = read_spec_file(feature_dir, "spec.md")?;
    let context = ContextBuilder::new()
        .add_variable("feature_slug", state_manager.state().feature.slug.clone())?
        .add_variable("spec_content", spec_content)?
        .add_variable("repo_path", repo_path.display().to_string())?
        .build()?;

    // 3. æ¸²æŸ“æç¤ºè¯
    let (system_prompt, user_prompt) = pm.render_task(&task_template, &context)?;

    if dry_run {
        println!("ğŸ” [DRY RUN] æ¨¡æ‹Ÿæ‰§è¡Œ Phase 1");
        println!("User Prompt é•¿åº¦: {} å­—ç¬¦", user_prompt.len());
        return Ok(());
    }

    // 4. æ‰§è¡Œ Phase
    println!("âš™ï¸  æ‰§è¡Œä¸­...");
    let result = engine
        .execute_phase_with_config(
            Phase::Observer,
            &task_template.config,
            system_prompt,
            user_prompt,
        )
        .await?;

    // 5. ä¿å­˜è¾“å‡º
    save_phase_output(1, &result.message, feature_dir)?;

    // 6. æ›´æ–°ç»Ÿè®¡
    let state = state_manager.state_mut();
    state.cost_summary.total_turns = state.cost_summary.total_turns.saturating_add(result.turns);
    state.cost_summary.total_cost_usd += result.cost_usd;

    Ok(())
}

/// Phase 2: Planning - åˆ¶å®šè®¡åˆ’
async fn execute_planning_phase(
    engine: &mut ExecutionEngine,
    state_manager: &mut StateManager,
    pm: &PromptManager,
    feature_dir: &Path,
    repo_path: &Path,
    dry_run: bool,
) -> anyhow::Result<()> {
    println!("ğŸ“ Phase 2: Planning - åˆ¶å®šè®¡åˆ’");

    // 1. åŠ è½½æ¨¡æ¿
    let task_dir = PathBuf::from("crates/ca-pm/templates/run/phase2_planning");
    let task_template = pm.load_task_dir(&task_dir)?;

    // 2. è¯»å– Phase 1 è¾“å‡º
    let phase1_output = read_phase_output(feature_dir, 1)?;

    // 3. æ„å»ºä¸Šä¸‹æ–‡
    let spec_content = read_spec_file(feature_dir, "spec.md")?;
    let design_content = read_spec_file(feature_dir, "design.md")?;
    let context = ContextBuilder::new()
        .add_variable("feature_slug", state_manager.state().feature.slug.clone())?
        .add_variable("spec_content", spec_content)?
        .add_variable("design_content", design_content)?
        .add_variable("observer_output", phase1_output)?
        .build()?;

    // 4. æ¸²æŸ“æç¤ºè¯
    let (system_prompt, user_prompt) = pm.render_task(&task_template, &context)?;

    if dry_run {
        println!("ğŸ” [DRY RUN] æ¨¡æ‹Ÿæ‰§è¡Œ Phase 2");
        return Ok(());
    }

    // 5. æ‰§è¡Œ Phase
    println!("âš™ï¸  æ‰§è¡Œä¸­...");
    let result = engine
        .execute_phase_with_config(
            Phase::Planning,
            &task_template.config,
            system_prompt,
            user_prompt,
        )
        .await?;

    // 6. ä¿å­˜è¾“å‡º
    save_phase_output(2, &result.message, feature_dir)?;

    // 7. æ›´æ–°ç»Ÿè®¡
    let state = state_manager.state_mut();
    state.total_stats.turns += result.turns;
    state.total_stats.cost_usd += result.cost_usd;

    Ok(())
}

/// Phase 3/4: Execute - æ‰§è¡Œå®æ–½
async fn execute_execute_phase(
    engine: &mut ExecutionEngine,
    state_manager: &mut StateManager,
    pm: &PromptManager,
    feature_dir: &Path,
    repo_path: &Path,
    phase_num: u8,
    dry_run: bool,
) -> anyhow::Result<()> {
    println!("âš¡ Phase {}: Execute - æ‰§è¡Œå®æ–½", phase_num);

    // 1. åŠ è½½æ¨¡æ¿
    let task_dir = PathBuf::from(format!(
        "crates/ca-pm/templates/run/phase{}_execute",
        phase_num
    ));
    let task_template = pm.load_task_dir(&task_dir)?;

    // 2. è¯»å–ä¹‹å‰çš„è¾“å‡º
    let phase2_output = read_phase_output(feature_dir, 2)?;
    let mut context_builder = ContextBuilder::new()
        .add_variable("feature_slug", state_manager.state().feature.slug.clone())?
        .add_variable("plan_output", phase2_output)?;

    // Phase 4 éœ€è¦ Phase 3 çš„è¾“å‡º
    if phase_num == 4 {
        let phase3_output = read_phase_output(feature_dir, 3)?;
        context_builder = context_builder.add_variable("phase3_output", phase3_output)?;
    }

    let context = context_builder.build()?;

    // 3. æ¸²æŸ“æç¤ºè¯
    let (system_prompt, user_prompt) = pm.render_task(&task_template, &context)?;

    if dry_run {
        println!("ğŸ” [DRY RUN] æ¨¡æ‹Ÿæ‰§è¡Œ Phase {}", phase_num);
        return Ok(());
    }

    // 4. æ‰§è¡Œ Phase
    println!("âš™ï¸  æ‰§è¡Œä¸­...");
    let phase = if phase_num == 3 {
        Phase::ExecutePhase3
    } else {
        Phase::ExecutePhase4
    };

    let result = engine
        .execute_phase_with_config(phase, &task_template.config, system_prompt, user_prompt)
        .await?;

    // 5. ä¿å­˜è¾“å‡º
    save_phase_output(phase_num, &result.message, feature_dir)?;

    // 6. æ›´æ–°ç»Ÿè®¡
    let state = state_manager.state_mut();
    state.cost_summary.total_turns = state.cost_summary.total_turns.saturating_add(result.turns);
    state.cost_summary.total_cost_usd += result.cost_usd;

    Ok(())
}

/// Phase 5: Review - ä»£ç å®¡æŸ¥ (å¸¦ Fix å¾ªç¯)
async fn execute_review_phase(
    engine: &mut ExecutionEngine,
    state_manager: &mut StateManager,
    pm: &PromptManager,
    feature_dir: &Path,
    repo_path: &Path,
    dry_run: bool,
) -> anyhow::Result<()> {
    println!("ğŸ” Phase 5: Code Review (å¸¦è‡ªåŠ¨ä¿®å¤å¾ªç¯)");

    let matcher = KeywordMatcher::for_review();

    for iteration in 1..=MAX_FIX_ITERATIONS {
        println!("  è¿­ä»£ {}/{}", iteration, MAX_FIX_ITERATIONS);

        // 1. åŠ è½½æ¨¡æ¿
        let task_dir = PathBuf::from("crates/ca-pm/templates/run/phase5_review");
        let task_template = pm.load_task_dir(&task_dir)?;

        // 2. æ”¶é›†ä»£ç å˜æ›´
        let changes = collect_code_changes(repo_path)?;

        // 3. æ„å»ºä¸Šä¸‹æ–‡
        let context = ContextBuilder::new()
            .add_variable("feature_slug", state_manager.state().feature.slug.clone())?
            .add_variable("changes", changes)?
            .add_variable("iteration", iteration)?
            .build()?;

        // 4. æ¸²æŸ“æç¤ºè¯
        let (system_prompt, user_prompt) = pm.render_task(&task_template, &context)?;

        if dry_run {
            println!("ğŸ” [DRY RUN] æ¨¡æ‹Ÿæ‰§è¡Œ Review è¿­ä»£ {}", iteration);
            continue;
        }

        // 5. æ‰§è¡Œ Review
        println!("âš™ï¸  æ‰§è¡Œå®¡æŸ¥ä¸­...");
        let result = engine
            .execute_phase_with_config(
                Phase::Review,
                &task_template.config,
                system_prompt,
                user_prompt,
            )
            .await?;

        // 6. ä¿å­˜è¾“å‡º
        save_phase_output(5, &result.message, feature_dir)?;

        // 7. æ£€æŸ¥å…³é”®è¯
        match matcher.check(&result.message) {
            Some(true) => {
                println!("âœ… ä»£ç å®¡æŸ¥é€šè¿‡! (APPROVED)");
                
                // æ›´æ–°ç»Ÿè®¡
                let state = state_manager.state_mut();
                state.total_stats.turns += result.turns;
                state.total_stats.cost_usd += result.cost_usd;
                
                return Ok(());
            }
            Some(false) => {
                println!("âš ï¸  éœ€è¦ä¿®å¤é—®é¢˜ (NEEDS_CHANGES)");

                if iteration < MAX_FIX_ITERATIONS {
                    // æ‰§è¡Œ Fix
                    println!("  â†’ æ‰§è¡Œè‡ªåŠ¨ä¿®å¤...");
                    execute_fix_phase_iteration(
                        engine,
                        state_manager,
                        pm,
                        feature_dir,
                        &result.message,
                        dry_run,
                    )
                    .await?;
                } else {
                    println!("âŒ è¾¾åˆ°æœ€å¤§è¿­ä»£æ¬¡æ•° ({})", MAX_FIX_ITERATIONS);
                    anyhow::bail!(
                        "Review åœ¨ {} æ¬¡è¿­ä»£åä»æœªé€šè¿‡",
                        MAX_FIX_ITERATIONS
                    );
                }
            }
            None => {
                println!("âš ï¸  å®¡æŸ¥ç»“æœä¸æ˜ç¡® (æœªæ‰¾åˆ° APPROVED æˆ– NEEDS_CHANGES å…³é”®è¯)");
                println!("   è¯·æ£€æŸ¥è¾“å‡º: specs/{}/.ca-state/phase5_output.md", state_manager.state().feature.slug);
                
                // è¯¢é—®ç”¨æˆ·
                println!("\næ˜¯å¦ç»§ç»­? (y/n): ");
                let mut input = String::new();
                std::io::stdin().read_line(&mut input)?;
                
                if input.trim().to_lowercase() != "y" {
                    anyhow::bail!("ç”¨æˆ·å–æ¶ˆ");
                }
                
                // å‡è®¾é€šè¿‡
                return Ok(());
            }
        }
    }

    Ok(())
}

/// Fix è¿­ä»£ (åœ¨ Review å¾ªç¯å†…éƒ¨è°ƒç”¨)
async fn execute_fix_phase_iteration(
    engine: &mut ExecutionEngine,
    state_manager: &mut StateManager,
    pm: &PromptManager,
    feature_dir: &Path,
    review_output: &str,
    dry_run: bool,
) -> anyhow::Result<()> {
    // 1. åŠ è½½æ¨¡æ¿
    let task_dir = PathBuf::from("crates/ca-pm/templates/run/phase6_fix");
    let task_template = pm.load_task_dir(&task_dir)?;

    // 2. æ„å»ºä¸Šä¸‹æ–‡
    let context = ContextBuilder::new()
        .add_variable("feature_slug", state_manager.state().feature.slug.clone())?
        .add_variable("review_output", review_output)?
        .build()?;

    // 3. æ¸²æŸ“æç¤ºè¯
    let (system_prompt, user_prompt) = pm.render_task(&task_template, &context)?;

    if dry_run {
        println!("ğŸ” [DRY RUN] æ¨¡æ‹Ÿæ‰§è¡Œ Fix");
        return Ok(());
    }

    // 4. æ‰§è¡Œ Fix
    let result = engine
        .execute_phase_with_config(Phase::Fix, &task_template.config, system_prompt, user_prompt)
        .await?;

    // 5. ä¿å­˜è¾“å‡º
    save_phase_output(6, &result.message, feature_dir)?;

    // 6. æ›´æ–°ç»Ÿè®¡
    let state = state_manager.state_mut();
    state.cost_summary.total_cost_usd += result.cost_usd;
    state.cost_summary.total_tokens_input += result.tokens_used;
    state.cost_summary.total_tokens_output += result.tokens_used / 2; // ä¼°ç®—

    println!("  âœ… ä¿®å¤å®Œæˆ");

    Ok(())
}

/// Phase 6: Fix - åº”ç”¨ä¿®å¤ (ç‹¬ç«‹è°ƒç”¨)
async fn execute_fix_phase(
    engine: &mut ExecutionEngine,
    state_manager: &mut StateManager,
    pm: &PromptManager,
    feature_dir: &Path,
    _repo_path: &Path,
    dry_run: bool,
) -> anyhow::Result<()> {
    println!("ğŸ”§ Phase 6: Fix - åº”ç”¨ä¿®å¤");

    // è¯»å– Review è¾“å‡º
    let review_output = read_phase_output(feature_dir, 5)?;

    execute_fix_phase_iteration(
        engine,
        state_manager,
        pm,
        feature_dir,
        &review_output,
        dry_run,
    )
    .await
}

/// Phase 7: Verification - éªŒè¯æµ‹è¯•
async fn execute_verification_phase(
    engine: &mut ExecutionEngine,
    state_manager: &mut StateManager,
    pm: &PromptManager,
    feature_dir: &Path,
    repo_path: &Path,
    dry_run: bool,
) -> anyhow::Result<()> {
    println!("âœ… Phase 7: Verification - éªŒè¯æµ‹è¯•");

    // 1. åŠ è½½æ¨¡æ¿
    let task_dir = PathBuf::from("crates/ca-pm/templates/run/phase7_verification");
    let task_template = pm.load_task_dir(&task_dir)?;

    // 2. æ„å»ºä¸Šä¸‹æ–‡
    let spec_content = read_spec_file(feature_dir, "spec.md")?;
    let context = ContextBuilder::new()
        .add_variable("feature_slug", state_manager.state().feature.slug.clone())?
        .add_variable("spec_content", spec_content)?
        .add_variable("repo_path", repo_path.display().to_string())?
        .build()?;

    // 3. æ¸²æŸ“æç¤ºè¯
    let (system_prompt, user_prompt) = pm.render_task(&task_template, &context)?;

    if dry_run {
        println!("ğŸ” [DRY RUN] æ¨¡æ‹Ÿæ‰§è¡Œ Phase 7");
        return Ok(());
    }

    // 4. æ‰§è¡Œ Phase
    println!("âš™ï¸  æ‰§è¡Œä¸­...");
    let result = engine
        .execute_phase_with_config(
            Phase::Verification,
            &task_template.config,
            system_prompt,
            user_prompt,
        )
        .await?;

    // 5. ä¿å­˜è¾“å‡º
    save_phase_output(7, &result.message, feature_dir)?;

    // 6. æ£€æŸ¥å…³é”®è¯
    let matcher = KeywordMatcher::for_verification();
    match matcher.check(&result.message) {
        Some(true) => {
            println!("âœ… éªŒè¯é€šè¿‡! (VERIFIED)");
        }
        Some(false) => {
            println!("âŒ éªŒè¯å¤±è´¥! (FAILED)");
            anyhow::bail!("éªŒè¯æœªé€šè¿‡,è¯·æ£€æŸ¥æµ‹è¯•ç»“æœ");
        }
        None => {
            println!("âš ï¸  éªŒè¯ç»“æœä¸æ˜ç¡®");
        }
    }

    // 7. æ›´æ–°ç»Ÿè®¡
    let state = state_manager.state_mut();
    state.total_stats.turns += result.turns;
    state.total_stats.cost_usd += result.cost_usd;

    Ok(())
}

/// æ¢å¤ä¸­æ–­çš„æ‰§è¡Œ
async fn resume_execution(
    mut state_manager: StateManager,
    repo_path: &Path,
    feature_dir: &Path,
    dry_run: bool,
    skip_review: bool,
    skip_test: bool,
    config: &AppConfig,
) -> anyhow::Result<()> {
    let state = state_manager.state();
    let current_phase = state.status.current_phase;

    println!("ğŸ“Š å½“å‰è¿›åº¦:");
    println!("  - å½“å‰é˜¶æ®µ: Phase {}", current_phase);
    println!("  - å®Œæˆç™¾åˆ†æ¯”: {}%", state.status.completion_percentage);
    println!();

    // ç”Ÿæˆæ¢å¤ä¸Šä¸‹æ–‡
    let resume_context = state_manager.generate_resume_context();
    println!("ğŸ”„ æ¢å¤ä¸Šä¸‹æ–‡:");
    println!("{}", resume_context);
    println!();

    // åˆ›å»º Agent å’Œ Engine
    let repository = Arc::new(Repository::new(repo_path)?);
    let agent = create_agent(config)?;
    let event_handler = Box::new(CliEventHandler::new());
    let mut engine = ExecutionEngine::new(agent, repository)
        .with_event_handler(event_handler);

    // åˆ›å»º PromptManager
    let prompt_config = PromptConfig {
        template_dir: config.prompt.template_dir.clone(),
        default_template: None,
    };
    let prompt_manager = PromptManager::new(prompt_config)?;

    // ä»å½“å‰é˜¶æ®µç»§ç»­æ‰§è¡Œ (é€’å½’è°ƒç”¨ä¸»é€»è¾‘)
    // ç®€åŒ–ç‰ˆæœ¬:ç›´æ¥ä½¿ç”¨ execute_run çš„é€»è¾‘
    println!("ğŸš€ ä» Phase {} ç»§ç»­æ‰§è¡Œ...", current_phase);

    // TODO: å®ç°ä½¿ç”¨ resume.jinja æ¨¡æ¿çš„æ¢å¤é€»è¾‘
    // è¿™é‡Œæš‚æ—¶ä½¿ç”¨æ­£å¸¸æµç¨‹

    for phase_num in current_phase..=7 {
        println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        println!("Phase {}: {}", phase_num, get_phase_name(phase_num));
        println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        println!();

        // è·³è¿‡é€»è¾‘ (åŒä¸»æµç¨‹)
        if skip_review && phase_num == 5 {
            println!("â­ï¸  è·³è¿‡ä»£ç å®¡æŸ¥");
            state_manager.update_phase_status(phase_num, Status::Completed)?;
            continue;
        }

        if skip_test && phase_num == 7 {
            println!("â­ï¸  è·³è¿‡æµ‹è¯•éªŒè¯");
            state_manager.update_phase_status(phase_num, Status::Completed)?;
            continue;
        }

        // æ‰§è¡Œé˜¶æ®µ (åŒä¸»æµç¨‹)
        match phase_num {
            1 => {
                execute_observer_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    feature_dir,
                    repo_path,
                    dry_run,
                )
                .await?
            }
            2 => {
                execute_planning_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    feature_dir,
                    repo_path,
                    dry_run,
                )
                .await?
            }
            3 | 4 => {
                execute_execute_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    feature_dir,
                    repo_path,
                    phase_num,
                    dry_run,
                )
                .await?
            }
            5 => {
                execute_review_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    feature_dir,
                    repo_path,
                    dry_run,
                )
                .await?
            }
            6 => {
                execute_fix_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    feature_dir,
                    repo_path,
                    dry_run,
                )
                .await?
            }
            7 => {
                execute_verification_phase(
                    &mut engine,
                    &mut state_manager,
                    &prompt_manager,
                    feature_dir,
                    repo_path,
                    dry_run,
                )
                .await?
            }
            _ => anyhow::bail!("æ— æ•ˆçš„ phase ç¼–å·: {}", phase_num),
        }

        state_manager.update_phase_status(phase_num, Status::Completed)?;
        state_manager.save()?;
        println!("âœ… Phase {} å®Œæˆ", phase_num);
        println!();
    }

    println!("ğŸ‰ æ¢å¤æ‰§è¡Œå®Œæˆ!");
    Ok(())
}

/// ç”Ÿæˆ Pull Request
async fn generate_pr(
    feature_slug: &str,
    feature_dir: &Path,
    _repo_path: &Path,
) -> anyhow::Result<String> {
    // è¯»å–åŠŸèƒ½è§„æ ¼ç”Ÿæˆ PR æè¿°
    let spec = read_spec_file(feature_dir, "spec.md")?;
    let summary = extract_summary(&spec);

    // ç”Ÿæˆ PR æ ‡é¢˜
    let pr_title = format!("feat: {}", feature_slug.replace('-', " "));

    // ç”Ÿæˆ PR æè¿°
    let pr_body = format!(
        r#"## Summary

{}

## Specs

See `specs/{}/` for detailed specifications.

## Checklist

- [x] Implementation complete
- [x] Tests added
- [x] Documentation updated
- [x] Code reviewed

"#,
        summary, feature_slug
    );

    // ä½¿ç”¨ gh cli åˆ›å»º PR
    let output = tokio::process::Command::new("gh")
        .args([
            "pr",
            "create",
            "--title",
            &pr_title,
            "--body",
            &pr_body,
            "--head",
            &format!("feature/{}", feature_slug),
        ])
        .output()
        .await?;

    if output.status.success() {
        let pr_url = String::from_utf8_lossy(&output.stdout).trim().to_string();
        Ok(pr_url)
    } else {
        let error = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("gh pr create failed: {}", error)
    }
}

//
// è¾…åŠ©å‡½æ•°
//

fn determine_repo_path(
    repo: Option<PathBuf>,
    default_repo: &Option<PathBuf>,
) -> anyhow::Result<PathBuf> {
    if let Some(path) = repo {
        Ok(path)
    } else if let Some(default) = default_repo {
        Ok(default.clone())
    } else {
        std::env::current_dir().map_err(Into::into)
    }
}

fn find_feature_dir(repo_path: &Path, feature_slug: &str) -> anyhow::Result<PathBuf> {
    let specs_dir = repo_path.join("specs");

    // æŸ¥æ‰¾åŒ¹é…çš„ç›®å½•
    for entry in std::fs::read_dir(&specs_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                if name.ends_with(feature_slug) {
                    return Ok(path);
                }
            }
        }
    }

    anyhow::bail!("åŠŸèƒ½ç›®å½•æœªæ‰¾åˆ°: {}", feature_slug)
}

fn get_phase_name(phase_num: u8) -> &'static str {
    match phase_num {
        1 => "Observer - é¡¹ç›®åˆ†æ",
        2 => "Planning - åˆ¶å®šè®¡åˆ’",
        3 => "Execute Phase 1 - æ‰§è¡Œå®æ–½",
        4 => "Execute Phase 2 - æ‰§è¡Œå®æ–½",
        5 => "Review - ä»£ç å®¡æŸ¥",
        6 => "Fix - åº”ç”¨ä¿®å¤",
        7 => "Verification - éªŒè¯æµ‹è¯•",
        _ => "Unknown",
    }
}

fn read_spec_file(feature_dir: &Path, filename: &str) -> anyhow::Result<String> {
    let path = feature_dir.join(filename);
    if path.exists() {
        std::fs::read_to_string(path).map_err(Into::into)
    } else {
        Ok(String::new())
    }
}

fn read_phase_output(feature_dir: &Path, phase_num: u8) -> anyhow::Result<String> {
    let filename = format!("phase{}_output.md", phase_num);
    let state_dir = feature_dir.join(".ca-state");
    let path = state_dir.join(filename);

    if path.exists() {
        std::fs::read_to_string(path).map_err(Into::into)
    } else {
        Ok(String::new())
    }
}

fn save_phase_output(phase_num: u8, output: &str, feature_dir: &Path) -> anyhow::Result<()> {
    let state_dir = feature_dir.join(".ca-state");
    std::fs::create_dir_all(&state_dir)?;

    let filename = format!("phase{}_output.md", phase_num);
    let path = state_dir.join(filename);

    std::fs::write(path, output)?;
    Ok(())
}

fn collect_code_changes(repo_path: &Path) -> anyhow::Result<String> {
    // ä½¿ç”¨ git diff æ”¶é›†å˜æ›´
    let output = std::process::Command::new("git")
        .current_dir(repo_path)
        .args(["diff", "--cached"])
        .output()?;

    let cached_diff = String::from_utf8_lossy(&output.stdout).to_string();

    // å¦‚æœæ²¡æœ‰ staged å˜æ›´,è·å– unstaged å˜æ›´
    if cached_diff.trim().is_empty() {
        let output = std::process::Command::new("git")
            .current_dir(repo_path)
            .args(["diff"])
            .output()?;
        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    } else {
        Ok(cached_diff)
    }
}

fn extract_summary(spec: &str) -> String {
    // æå–è§„æ ¼ä¸­çš„æ¦‚è¿°éƒ¨åˆ†
    spec.lines()
        .skip_while(|line| !line.starts_with("## Overview") && !line.starts_with("## æ¦‚è¿°"))
        .skip(1)
        .take_while(|line| !line.starts_with("##"))
        .collect::<Vec<_>>()
        .join("\n")
        .trim()
        .to_string()
}

fn extract_pr_number(pr_url: &str) -> anyhow::Result<u32> {
    // ä» PR URL ä¸­æå–ç¼–å·
    // ä¾‹å¦‚: https://github.com/user/repo/pull/123
    pr_url
        .split('/')
        .next_back()
        .and_then(|s| s.parse().ok())
        .ok_or_else(|| anyhow::anyhow!("æ— æ³•ä» PR URL æå–ç¼–å·"))
}

fn create_agent(config: &AppConfig) -> anyhow::Result<Arc<dyn ca_core::Agent>> {
    use ca_core::{AgentConfig, AgentFactory, AgentType};

    let agent_type = match config.agent.agent_type.as_str() {
        "claude" => AgentType::Claude,
        "cursor" => AgentType::Cursor,
        "copilot" => AgentType::Copilot,
        _ => anyhow::bail!("ä¸æ”¯æŒçš„ Agent ç±»å‹: {}", config.agent.agent_type),
    };

    let agent_config = AgentConfig {
        agent_type,
        api_key: config.agent.api_key.clone(),
        model: Some(config.agent.model.clone()),
        api_url: config.agent.api_url.clone(),
    };

    AgentFactory::create(agent_config).map_err(Into::into)
}
