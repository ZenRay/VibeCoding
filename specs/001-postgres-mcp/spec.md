# 功能规格说明：PostgreSQL 自然语言查询 MCP 服务器

**功能分支**: `001-postgres-mcp`
**创建日期**: 2026-01-28
**最后更新**: 2026-01-29
**状态**: Phase 4 完成 - 查询历史功能实现 ✅
**输入**: 用户描述："主要的需求是在Python下面创建一个Postgres的mcp：用户可以给特定自然语言描述的查询的需求，然后mcp server 根据结果来返回一个SQL或者返回这个查询的结果。mcp的服务器在启动的时候，应该读取它都有哪些可以访问的数据库，并且缓存这些数据库的schema：了解每一个数据库下面都有哪些 table/view/types/index 等等，然后根据这些信息以及用户的输入去调用OpenAI的大模型（gpt-5-mini）来生成 SQL。之后mcp server应该来校验这个sql只允许查询的语句然后测试这个sql确保它能够执行并且返回有意义的结果：这里也可以把用户的输入生成的sql以及返回的结果的一部分调用openai来确认这样可以确保它的结果是不是有意义。最后根据用户的输入是返回SQL还是返回SQL查询之后的结果来返回相应的内容"

## 用户场景与测试 *(必填)*

### 用户故事 1 - 自然语言查询转 SQL 生成（优先级：P1）

开发者或数据分析师希望在不手动编写 SQL 的情况下查询 PostgreSQL 数据库。他们提供想要获取什么数据的自然语言描述，系统生成相应的 SQL 查询。

**优先级理由**：这是该功能的核心价值主张。它使用户无需 SQL 专业知识即可访问数据库信息，让数据库查询更加易用。即使没有额外功能，这也能立即提供价值。

**独立测试**：可以通过向 MCP 服务器发送自然语言查询请求（例如"显示过去 7 天创建的所有用户"）并接收有效的 SELECT SQL 查询来完全测试。成功的标准是查询在语法上正确且语义上与请求匹配。

**验收场景**：

1. **给定**已连接数据库且已缓存 schema，**当**用户发送"查找 2026 年 1 月下单的所有客户"，**那么**系统返回有效的 SELECT 查询，正确关联 customers 和 orders 表并带有适当的日期过滤
2. **给定**具有多个表的数据库，**当**用户请求"按类别统计产品总数"，**那么**系统返回带有 GROUP BY 和 COUNT 聚合的 SQL 查询
3. **给定**模糊的请求，**当**用户发送"显示用户"，**那么**系统生成合理的默认查询（例如带 LIMIT 的 SELECT *）或请求澄清
4. **给定**复杂的多表查询需求，**当**用户描述关系和条件，**那么**系统生成带有 WHERE 子句的适当 JOIN 语句

---

### 用户故事 2 - 执行查询并返回结果（优先级：P2）

用户不仅希望获得 SQL，还希望立即执行并查看结果，省去手动运行查询的步骤。

**优先级理由**：这建立在 P1 的基础上，提供端到端的工作流自动化。虽然单独的 SQL 生成就很有价值，但自动执行显著改善了用户体验和生产力。可以在 P1 之后独立开发和测试。

**独立测试**：可以通过发送带有"执行"标志的自然语言查询并接收结构化查询结果（行/列）来完全测试。当结果与生成的 SQL 返回的结果匹配时测试通过。

**验收场景**：

1. **给定**启用执行模式的自然语言查询请求，**当**用户发送"列出销量前 10 的产品"，**那么**系统返回 SQL 查询和实际的产品数据结果集
2. **给定**返回大型结果集的查询，**当**用户执行查询，**那么**系统返回带分页支持或行数限制的结果
3. **给定**没有匹配记录的查询，**当**用户执行查询，**那么**系统返回空结果集并带有适当的消息
4. **给定**运行缓慢的查询，**当**执行超过超时阈值，**那么**系统取消查询并返回超时错误

---

### 用户故事 3 - 数据库 Schema 发现和缓存（优先级：P1）

MCP 服务器需要理解所连接数据库的结构才能生成准确的 SQL 查询。在启动时，应该发现并缓存 schema 信息。

**优先级理由**：这是 P1 所需的基础设施。没有 schema 知识，准确的 SQL 生成是不可能的。必须在 P1 之前或同时实现，以提供查询生成所需的上下文。

**独立测试**：可以通过启动服务器、验证 schema 缓存已填充、检查缓存包含表、视图、列、数据类型、索引和关系来独立测试。当 schema 查询返回预期的元数据时测试通过。

**验收场景**：

1. **给定**数据库连接配置，**当**MCP 服务器启动，**那么**系统读取并缓存所有可访问数据库的 schemas、表、视图、列、数据类型和索引
2. **给定**具有外键关系的数据库，**当**缓存 schema，**那么**系统存储关系信息用于 JOIN 查询生成
3. **给定**配置了多个数据库，**当**服务器启动，**那么**系统缓存所有可访问数据库的 schemas
4. **给定**已缓存的 schema 数据，**当**用户请求可用表的信息，**那么**系统返回 schema 信息而不查询数据库
5. **给定**数据库 schema 更改（添加新表），**当**触发 schema 刷新，**那么**系统用新的 schema 信息更新缓存

---

### 用户故事 4 - SQL 安全验证（优先级：P1）

为了防止破坏性操作，系统必须验证生成的 SQL 仅包含安全的读取操作（SELECT 查询），阻止任何数据修改语句。

**优先级理由**：这是必须与 P1 一起实现的关键安全需求。没有它，系统会带来数据完整性风险。这对于生产使用是不可协商的。

**独立测试**：可以通过尝试生成或执行各种 SQL 类型（INSERT、UPDATE、DELETE、DROP、ALTER）并验证它们被阻止来测试。当只允许 SELECT 语句通过时测试通过。

**验收场景**：

1. **给定**生成的 SQL 查询，**当**系统验证查询，**那么**只允许 SELECT 语句，阻止所有 DML/DDL 语句
2. **给定**恶意或意外的请求如"删除所有记录"，**当**AI 首次生成 DELETE 查询被拒绝，**那么**系统自动重新请求 AI 仅生成只读查询，若第二次仍失败则返回错误
3. **给定**带有子查询或 CTE 的查询，**当**系统验证，**那么**所有嵌套查询也被验证为只读
4. **给定**带有试图隐藏恶意代码的 SQL 注释的查询，**当**验证发生，**那么**系统去除注释并验证实际的 SQL

---

### 用户故事 5 - 查询结果验证（优先级：P3）

在返回结果之前，系统应该验证查询成功执行并返回有意义的结果，可选地使用 AI 验证结果相关性。

**优先级理由**：这是改善准确性的质量提升功能，但对 MVP 不是必需的。可以在核心功能（P1、P2）稳定后添加。

**独立测试**：可以通过执行查询并检查系统验证来测试：（1）查询无错误运行，（2）在预期时结果非空，（3）可选地，结果在语义上与原始请求匹配。当验证捕获常见问题时测试通过。

**验收场景**：

1. **给定**生成的 SQL 查询，**当**系统测试执行，**那么**查询成功运行并返回结果或适当的错误消息
2. **给定**查询结果和原始自然语言请求，**当**系统验证相关性，**那么**AI 模型确认结果与用户意图匹配或建议查询改进
3. **给定**返回意外空结果的查询，**当**验证发生，**那么**系统建议替代查询或请求澄清
4. **给定**有语法错误的查询，**当**系统测试执行，**那么**在返回给用户之前捕获错误，并且系统尝试修复或重新生成查询

---

### 用户故事 6 - 多数据库支持（优先级：P2）

用户可能可以访问多个 PostgreSQL 数据库，需要指定要查询哪个数据库或允许跨数据库查询。

**优先级理由**：这增强了灵活性，但对于单数据库用例不是必需的。可以在基本的单数据库功能工作后实现。

**独立测试**：可以通过配置多个数据库连接、发送针对特定数据库的查询、验证查询正确的数据库来测试。当查询路由到正确的数据库且 schema 上下文保持时测试通过。

**验收场景**：

1. **给定**配置了多个数据库，**当**用户在请求中指定数据库名称，**那么**系统使用正确的数据库 schema 上下文生成查询
2. **给定**未指定数据库，**当**用户发送查询，**那么**系统使用默认数据库或提示澄清
3. **给定**需要来自多个数据库的数据的查询，**当**用户描述跨数据库需求，**那么**系统返回错误表明不支持跨数据库查询（或生成适当的 dblink/FDW 查询，如果支持）

---

### 边界情况

- 在查询执行期间数据库连接丢失时会发生什么？
- 系统如何处理 5 个以上表连接的极其复杂的查询？
- 当自然语言请求模糊或匹配多个可能的查询时会发生什么？
- 系统如何处理表数量非常大（100+ 个表）的数据库 schema？
- 当达到 OpenAI API 速率限制或 API 不可用时会发生什么？（系统直接返回错误，尝试使用本地 SQL 模板库匹配常见查询模式作为降级方案）
- 系统如何处理请求用户无权访问的表中数据的查询？
- 当自然语言包含伪装成正常文本的 SQL 注入尝试时会发生什么？
- 系统如何处理具有极大结果集（数百万行）的查询？
- 当数据库 schema 包含表/列名称中的特殊字符或保留关键字时会发生什么？
- 系统如何处理来自多个用户的并发查询请求？

## 需求 *(必填)*

### 功能性需求

- **FR-001**: 系统必须通过 MCP 协议接受来自用户的自然语言查询描述
- **FR-002**: 系统必须支持两种数据库连接方式：（1）预配置连接 - 通过配置文件定义，环境变量可覆盖敏感值；（2）动态连接 - MCP 客户端在查询请求中临时传递连接信息
- **FR-003**: 系统必须在启动时发现并缓存数据库 schema 信息，包括表、视图、列、数据类型、索引、约束和外键关系
- **FR-004**: 系统必须使用 OpenAI 的 GPT-4o-mini 模型从自然语言描述结合 schema 上下文生成 SQL 查询
- **FR-005**: 系统必须验证所有生成的 SQL 以确保只允许 SELECT 语句，阻止 INSERT、UPDATE、DELETE、DROP、ALTER、TRUNCATE 和其他修改/DDL 语句；如验证失败，向 AI 模型重新请求时明确指定"仅生成只读 SELECT 查询"，最多重试 1 次
- **FR-006**: 系统必须针对目标数据库测试生成的 SQL 执行，以验证它无错误运行
- **FR-007**: 系统必须支持两种响应模式：（1）仅返回 SQL 查询，（2）返回 SQL 查询和执行结果
- **FR-008**: 系统必须优雅地处理 SQL 执行错误并向用户返回有意义的错误消息
- **FR-009**: 系统必须限制查询结果集以防止内存耗尽（默认限制：1000 行）
- **FR-010**: 系统必须提供 schema 刷新功能以在不重启服务器的情况下更新缓存的元数据，采用周期性轮询机制（可配置间隔，默认每 5 分钟）检查 schema 变化，同时支持手动触发刷新命令
- **FR-011**: 系统必须记录所有查询生成尝试到 JSON Lines 格式日志文件，包括时间戳、自然语言输入、生成的 SQL、执行结果/错误，日志文件按日期轮转（保留最近 30 天）
- **FR-012**: 系统必须支持多个数据库连接的配置，包括预配置的命名连接和临时动态连接
- **FR-013**: 系统必须为动态传递的数据库连接建立独立的 schema 缓存，缓存生命周期与连接会话绑定
- **FR-014**: 系统必须在启动时和运行期间定期验证数据库连接
- **FR-015**: 系统必须在自然语言请求无法转换为有效 SQL 时提供清晰的错误消息
- **FR-016**: 系统必须维护常见查询模板库（如"显示所有记录"、"按字段分组统计"等），当 OpenAI API 不可用时尝试模板匹配作为降级方案
- **FR-017**: 系统必须可选地通过向 OpenAI 发送原始请求、生成的 SQL 和样本结果来验证查询结果相关性
- **FR-018**: 系统必须实现请求超时以防止对慢查询的无限等待（可配置，默认：30 秒）
- **FR-019**: 系统必须清理和参数化生成的 SQL 中的任何动态值以防止注入攻击
- **FR-020**: 系统必须遵循 Model Context Protocol 规范暴露 MCP 工具/资源
- **FR-021**: 系统必须在 schema 缓存和查询生成中处理 PostgreSQL 特定的数据类型（数组、JSON、枚举等）
- **FR-022**: 系统必须提供查询历史跟踪用于调试和审计目的，查询历史存储在 JSONL 格式日志文件中，可通过标准文本工具或 jq 等工具查询分析

### 非功能性需求

- **NFR-001**: 系统必须在正常条件下 10 秒内响应自然语言查询（不包括 OpenAI API 延迟），安全验证失败自动重试时总响应时间不超过 15 秒
- **NFR-002**: 系统必须处理至少 10 个并发查询请求而不降级
- **NFR-003**: Schema 缓存必须存储在内存中以便在查询生成期间快速访问
- **NFR-004**: 系统必须支持 PostgreSQL 12.0 及以上版本
- **NFR-005**: 系统必须安全存储数据库凭据，预配置连接的密码支持环境变量覆盖，动态连接的凭据不持久化到磁盘
- **NFR-006**: 系统必须打包为与 MCP 客户端兼容的标准 MCP 服务器
- **NFR-007**: 系统必须包含全面的错误处理和日志记录以便故障排除
- **NFR-008**: 系统必须可通过 YAML/JSON 配置文件定义数据库连接和系统参数，环境变量可覆盖配置文件中的敏感值（如密码、API 密钥）
- **NFR-009**: Schema 缓存轮询间隔必须可配置，默认值为 5 分钟，支持范围 1-60 分钟
- **NFR-010**: 查询历史日志文件必须按日期轮转，默认保留 30 天，单个日志文件大小不超过 100MB

### 关键实体

- **Database Connection（数据库连接）**: 表示带有凭据、主机、端口、数据库名称和连接状态的 PostgreSQL 数据库连接
- **Schema Cache（Schema 缓存）**: 包含每个连接数据库的所有表、视图、列、数据类型、索引、约束和关系的元数据
- **Query Request（查询请求）**: 用户的自然语言数据描述、目标数据库标识符和响应模式（仅 SQL 或执行）
- **Generated Query（生成的查询）**: AI 模型生成的 SQL SELECT 语句、验证状态以及任何关联的警告或错误
- **Query Result（查询结果）**: 执行结果，包括列元数据、行数据、行数、执行时间以及遇到的任何错误
- **Query Log Entry（查询日志条目）**: 审计记录，包含时间戳、用户标识符、自然语言请求、生成的 SQL、执行状态和结果摘要

## 成功标准 *(必填)*

### 可衡量的结果

- **SC-001**: 用户可以成功从自然语言描述生成有效的 SQL 查询，对于常见查询模式（单表查询、简单连接、基本聚合）准确率达到 90% 以上
- **SC-002**: 系统在 95% 的请求中 5 秒内生成并返回 SQL 查询（不包括 OpenAI API 延迟）
- **SC-003**: 系统正确阻止 100% 的尝试数据修改操作（INSERT、UPDATE、DELETE、DDL 语句）
- **SC-004**: 对于最多 100 个表的数据库，Schema 缓存在 60 秒内完成
- **SC-005**: 对于返回最多 1000 行的查询，查询执行结果在 10 秒内返回
- **SC-006**: 系统在正常运行期间保持 99% 以上的正常运行时间，并处理临时数据库故障；在 OpenAI API 不可用时，通过本地模板库至少能处理 20% 的常见查询
- **SC-007**: 用户可以在不了解 SQL 的情况下查询数据库，对于非技术用户查询开发时间减少 70% 以上
- **SC-008**: 系统在 95% 以上的场景中成功处理边界情况（连接失败、API 速率限制、模糊查询）并提供清晰的错误消息
- **SC-009**: 生成的 SQL 在 85% 以上的情况下首次尝试通过 PostgreSQL 语法验证

## 假设

- 用户拥有具有只读访问权限（SELECT 权限）的有效 PostgreSQL 数据库凭据
- OpenAI API 访问对于预期查询量具有足够的速率限制
- MCP 客户端将提供英文自然语言查询（多语言支持可以稍后添加）
- 查询结果集通常包含少于 10,000 行（更大的数据集应使用分页或导出机制）
- 数据库 schemas 相对稳定（不是每小时多次更改）
- 用户理解基本的数据库概念（表、列、过滤），即使他们不懂 SQL 语法
- PostgreSQL 数据库遵循合理的命名约定（没有过多的特殊字符，保留关键字正确引用）
- 系统将在具有对 PostgreSQL 服务器和 OpenAI API 的网络访问的环境中运行
- 默认查询结果限制 1000 行对于大多数用例是可接受的
- 用户接受 AI 生成的查询在复杂场景中偶尔可能需要手动改进

## 依赖项

- PostgreSQL 数据库服务器（12.0+ 版本）具有可访问的连接端点
- OpenAI API 访问，具有 GPT-4o-mini 模型可用性
- MCP（Model Context Protocol）客户端用于交互
- Python 运行时环境（3.11+）
- 与数据库服务器和 OpenAI API 的网络连接

## 范围外

- 支持 PostgreSQL 以外的数据库（MySQL、SQL Server、Oracle 等）
- 数据修改操作（INSERT、UPDATE、DELETE）- 仅限只读查询
- 复杂的事务管理或多语句查询
- 查询性能优化或索引推荐
- 数据库管理任务（用户管理、备份、schema 迁移）
- 查询结果的自定义可视化或报告
- 实时查询监控或分析仪表板
- 支持存储过程、函数或触发器
- 跨数据库连接查询（除非使用 PostgreSQL 外部数据包装器）
- 超出数据库级别权限的身份验证/授权

## 澄清

### Session 2026-01-28

- Q: Schema 缓存更新策略 - 何时触发 schema 刷新？ → A: 周期性轮询 + 手动刷新 - 后台每 N 分钟检查 schema 变化，同时支持手动触发
- Q: OpenAI API 故障处理策略 - API 速率限制或不可用时如何处理？ → A: 直接失败 + 本地 SQL 模板 - 不重试，维护常见查询模板库作为降级方案
- Q: 查询历史存储方式 - 如何持久化查询历史记录？ → A: 日志文件（JSON Lines）- 追加写入 JSONL 格式文件，按日期轮转
- Q: 数据库连接配置方式 - 如何配置数据库连接信息？ → A: 配置文件 + 环境变量 + MCP 协议动态传递 - 支持预配置和运行时动态连接
- Q: SQL 验证失败时的行为 - 生成的 SQL 未通过安全验证时如何处理？ → A: 返回错误 + AI 重新生成 - 告知 AI 只生成 SELECT，最多重试 1 次
