<!--
SYNC IMPACT REPORT
==================
Version Change: (none) → 1.0.0
Change Type: Initial creation
Rationale: First constitution establishing project development principles

Principles Defined:
- I. Ergonomic Python & TypeScript
- II. Strict Type Annotations
- III. Pydantic Data Models
- IV. camelCase JSON Serialization
- V. No Authentication Required

Added Sections:
- Core Principles (5 principles)
- Technology Standards
- API & Data Standards
- Governance

Templates Requiring Updates:
✅ .specify/templates/plan-template.md - No updates needed (constitution-compliant workflow)
✅ .specify/templates/spec-template.md - No updates needed (constitution-compliant requirements)
✅ .specify/templates/tasks-template.md - No updates needed (constitution-compliant task structure)
⚠ .claude/commands/*.md - Should reference constitution for code generation standards

Follow-up TODOs:
- None (all placeholders filled)

Date: 2026-01-22
-->

# Database Query Tool Constitution

## Core Principles

### I. Ergonomic Python & TypeScript

Backend code MUST be written in Ergonomic Python style, emphasizing:
- Readability and expressiveness over brevity
- Clear variable and function names that communicate intent
- Pythonic idioms (list comprehensions, context managers, generators)
- Modern Python 3.12+ features (type unions with `|`, structural pattern matching)

Frontend code MUST be written in TypeScript, emphasizing:
- Clear, self-documenting code structure
- Functional programming patterns where appropriate
- Component composition and reusability
- Modern TypeScript features (discriminated unions, type inference, generics)

**Rationale**: Ergonomic code reduces cognitive load, improves maintainability, and accelerates
onboarding. TypeScript provides type safety for the frontend, preventing runtime errors.

### II. Strict Type Annotations

ALL functions, methods, and public APIs MUST include complete type annotations:

**Python Requirements**:
- Function signatures with parameter types and return types
- Class attributes with type hints
- Use of `typing` module for complex types (Optional, Union, List, Dict, etc.)
- Mypy compliance in strict mode
- Pydantic models for data validation

**TypeScript Requirements**:
- Explicit type annotations for function parameters and return types
- Interface definitions for all data structures
- No use of `any` type except in extraordinary circumstances (must be justified)
- Strict TypeScript configuration enabled (`strict: true`)
- Type-only imports where appropriate (`import type`)

**Rationale**: Type annotations serve as living documentation, enable IDE autocomplete,
catch errors at development time, and improve code maintainability. They are non-negotiable
for both backend and frontend.

### III. Pydantic Data Models

ALL data structures exchanged between components, stored in databases, or exposed via APIs
MUST be defined using Pydantic models:

- Request/response models for all API endpoints
- Database models inherit from or integrate with Pydantic
- Configuration objects use Pydantic BaseSettings
- Validation logic embedded in model definitions
- Automatic OpenAPI schema generation from models

**Rationale**: Pydantic provides runtime validation, serialization, and automatic documentation
generation. It enforces data integrity at system boundaries and eliminates manual validation
boilerplate.

### IV. camelCase JSON Serialization

ALL JSON data generated by the backend MUST use camelCase naming convention:

- API responses serialize to camelCase (e.g., `userId`, `firstName`, `createdAt`)
- Python snake_case internally converted to camelCase at serialization boundary
- Use Pydantic alias configuration: `Field(alias="camelCaseName")`
- Consistent naming between frontend TypeScript interfaces and backend JSON

**Example**:
```python
class UserResponse(BaseModel):
    user_id: int = Field(alias="userId")
    first_name: str = Field(alias="firstName")
    created_at: datetime = Field(alias="createdAt")

    class Config:
        populate_by_name = True
        json_schema_extra = {"by_alias": True}
```

**Rationale**: JavaScript/TypeScript convention is camelCase. Consistency reduces cognitive
friction, eliminates naming translation bugs, and improves frontend developer experience.

### V. No Authentication Required

The system is designed for open access with NO authentication or authorization:

- No user login, session management, or token validation
- All API endpoints publicly accessible
- No user-specific data isolation or permissions
- Database connections and queries accessible to anyone with access to the tool

**Security Implications**:
- System MUST NOT be exposed to untrusted networks
- Database credentials MUST be secured at infrastructure level
- SQL injection protection is CRITICAL (see Technology Standards)
- Suitable for internal tools, development environments, or trusted user bases

**Rationale**: Removing authentication simplifies architecture for internal/trusted tools.
Security is enforced at network/infrastructure boundaries rather than application level.

## Technology Standards

### Backend Stack

**Language & Framework**:
- Python 3.12+
- FastAPI (async framework)
- SQLAlchemy (ORM and query building)
- asyncpg / aiomysql / aiosqlite (async database drivers)

**Code Quality**:
- Black for code formatting
- Ruff for linting
- Mypy for type checking (strict mode)
- Pytest for testing

**Required Patterns**:
- Async/await for all I/O operations
- Dependency injection for testability
- Repository pattern for data access
- Service layer for business logic

### Frontend Stack

**Language & Framework**:
- TypeScript 5.0+
- React 18+
- Refine 5 (admin framework)
- Ant Design 5 (UI components)

**Code Quality**:
- Prettier for code formatting
- ESLint for linting
- TypeScript strict mode enabled
- Playwright for E2E testing

**Required Patterns**:
- Functional components with hooks
- Custom hooks for reusable logic
- Type-safe API client (generated from OpenAPI)
- Error boundaries for fault tolerance

## API & Data Standards

### API Design

**REST Conventions**:
- RESTful endpoint naming (plural resources: `/databases`, `/queries`)
- HTTP methods semantic usage (GET, POST, PUT, DELETE)
- Standard HTTP status codes (200, 201, 400, 404, 500)
- Consistent error response format

**Request/Response**:
- All requests and responses in JSON format
- camelCase keys in JSON (as per Principle IV)
- Pydantic models for validation (as per Principle III)
- OpenAPI/Swagger documentation auto-generated

### Data Validation

**Backend Validation**:
- Pydantic models validate all incoming data
- SQL injection protection (5-layer defense as documented)
- Query sanitization and whitelisting
- Connection string validation

**Frontend Validation**:
- TypeScript types enforce structure at compile time
- Form validation with Ant Design rules
- API response type validation
- Error handling with user-friendly messages

### SQL Security (CRITICAL)

**Mandatory SQL Injection Protections**:
1. Comment detection and blocking
2. Multi-statement prevention
3. Dangerous keyword filtering (DROP, DELETE without WHERE, TRUNCATE, etc.)
4. System table access restrictions
5. Syntax validation using sqlglot

**AI-Generated SQL Additional Protections**:
- Output sanitization
- Whitelist validation
- Subquery restrictions
- System function limitations

## Governance

### Amendment Procedure

1. **Proposal**: Document proposed change with rationale and impact analysis
2. **Review**: Assess impact on existing code, templates, and documentation
3. **Migration Plan**: Define migration strategy for breaking changes
4. **Approval**: Obtain team consensus (or project owner approval for solo projects)
5. **Update**: Modify constitution, increment version, update dependent artifacts
6. **Communication**: Announce changes and provide migration guidance

### Versioning Policy

Constitution versions follow Semantic Versioning (MAJOR.MINOR.PATCH):

- **MAJOR**: Backward-incompatible principle changes (e.g., removing authentication requirement,
  changing core technology stack)
- **MINOR**: New principles added or existing principles materially expanded (e.g., adding new
  security requirements, mandating additional testing practices)
- **PATCH**: Clarifications, wording improvements, typo fixes, non-semantic refinements

### Compliance Review

**All code changes MUST**:
- Adhere to type annotation requirements (Principles II)
- Use Pydantic for data models (Principle III)
- Serialize JSON to camelCase (Principle IV)
- Follow Ergonomic Python/TypeScript style (Principle I)
- Maintain no-authentication design (Principle V)

**Code Reviews MUST verify**:
- Type hints are present and accurate
- Pydantic models are used for API boundaries
- JSON responses use camelCase
- SQL injection protections are in place
- No authentication/authorization code is introduced

**Automated Checks**:
- Mypy type checking in CI/CD pipeline
- ESLint with TypeScript rules in CI/CD pipeline
- Unit and integration tests covering all API endpoints
- E2E tests for critical user workflows

### Complexity Justification

Any deviation from these principles MUST be:
1. Documented with clear rationale
2. Approved through amendment procedure
3. Time-boxed with plan to eliminate deviation
4. Reviewed for constitution amendment if pattern becomes recurring

**Version**: 1.0.0 | **Ratified**: 2026-01-22 | **Last Amended**: 2026-01-22
