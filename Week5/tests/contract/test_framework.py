"""
Contract testing framework for natural language to SQL conversion.

This module provides the base classes and utilities for testing the
accuracy and security of NL-to-SQL generation.
"""

import re
from dataclasses import dataclass
from enum import Enum
from functools import total_ordering
from typing import Any


@total_ordering
class TestCategory(Enum):
    """Test categories based on complexity and purpose."""

    L1_BASIC = "L1_BASIC"  # Basic queries
    L2_JOIN = "L2_JOIN"  # Multi-table joins
    L3_AGGREGATE = "L3_AGGREGATE"  # Aggregation analysis
    L4_COMPLEX = "L4_COMPLEX"  # Complex logic
    L5_ADVANCED = "L5_ADVANCED"  # Advanced features
    S1_SECURITY = "S1_SECURITY"  # Security tests

    def __lt__(self, other):
        """Define ordering for TestCategory."""
        if not isinstance(other, TestCategory):
            return NotImplemented
        order = [
            TestCategory.L1_BASIC,
            TestCategory.L2_JOIN,
            TestCategory.L3_AGGREGATE,
            TestCategory.L4_COMPLEX,
            TestCategory.L5_ADVANCED,
            TestCategory.S1_SECURITY,
        ]
        return order.index(self) < order.index(other)


class TestStatus(Enum):
    """Test execution status."""

    PENDING = "PENDING"
    PASSED = "PASSED"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"


@dataclass
class TestCase:
    """
    Represents a single NL-to-SQL test case.

    Attributes:
    ----------
        id: Unique test case identifier (e.g., "L1.1")
        category: Test category
        natural_language: Natural language query input
        database: Target database name
        expected_sql: Expected SQL query (for pattern matching)
        expected_behavior: Expected behavior for security tests
        validation_rules: List of validation rules to check
        description: Human-readable test description
    """

    id: str
    category: TestCategory
    natural_language: str
    database: str
    expected_sql: str | None = None
    expected_behavior: str | None = None
    validation_rules: list[str] | None = None
    description: str | None = None


@dataclass
class TestResult:
    """
    Represents the result of a test case execution.

    Attributes:
    ----------
        test_id: Test case identifier
        status: Test execution status
        generated_sql: SQL generated by the system
        execution_time_ms: Time taken to generate SQL
        error_message: Error message if test failed
        validation_details: Detailed validation results
    """

    test_id: str
    status: TestStatus
    generated_sql: str | None = None
    execution_time_ms: float | None = None
    error_message: str | None = None
    validation_details: dict[str, Any] | None = None


class SQLValidator:
    """
    Validates generated SQL against expected patterns and rules.

    This class provides methods to check SQL correctness using
    pattern matching, AST analysis, and custom validation rules.
    """

    @staticmethod
    def matches_pattern(generated_sql: str, expected_pattern: str) -> bool:
        """
        Check if generated SQL matches the expected pattern.

        Args:
        ----------
            generated_sql: SQL query generated by the system
            expected_pattern: Regex pattern for expected SQL

        Returns:
        ----------
            True if SQL matches pattern, False otherwise

        Example:
        ----------
            >>> validator = SQLValidator()
            >>> sql = "SELECT * FROM products"
            >>> pattern = r"SELECT .* FROM products"
            >>> validator.matches_pattern(sql, pattern)
            True
        """
        try:
            # Normalize SQL by replacing multiple whitespace with single space
            # This allows patterns to match regardless of formatting/newlines
            normalized_sql = " ".join(generated_sql.split())
            return bool(re.search(expected_pattern, normalized_sql, re.IGNORECASE))
        except re.error:
            return False

    @staticmethod
    def validate_security(generated_sql: str) -> tuple[bool, str]:
        """
        Validate SQL for security violations using AST parsing.

        Args:
        ----------
            generated_sql: SQL query to validate

        Returns:
        ----------
            Tuple of (is_safe, error_message)

        Example:
        ----------
            >>> validator = SQLValidator()
            >>> sql = "DROP TABLE products"
            >>> is_safe, msg = validator.validate_security(sql)
            >>> assert not is_safe
            >>> assert "DROP" in msg
        """
        import sqlglot
        from sqlglot import exp

        try:
            # Parse SQL into AST
            statements = sqlglot.parse(generated_sql, dialect="postgres")

            if not statements:
                return False, "No valid SQL statements found"

            # Check for multiple statements (SQL injection risk)
            if len(statements) > 1:
                return False, "Multiple statements not allowed"

            statement = statements[0]

            # Only SELECT statements are allowed
            if not isinstance(statement, exp.Select):
                stmt_type = type(statement).__name__
                return False, f"{stmt_type} statements are not allowed (read-only queries only)"

            # Check for dangerous operations in subqueries
            for node in statement.walk():
                if isinstance(
                    node,
                    (
                        exp.Insert,
                        exp.Update,
                        exp.Delete,
                        exp.Drop,
                        exp.Create,
                        exp.Alter,
                        exp.Command,
                        exp.Merge,
                    ),
                ):
                    stmt_type = type(node).__name__
                    return False, f"Dangerous operation in subquery: {stmt_type}"

            return True, ""

        except Exception as e:
            return False, f"SQL validation error: {e}"

    @staticmethod
    def check_validation_rules(generated_sql: str, rules: list[str]) -> dict[str, bool]:
        """
        Check SQL against custom validation rules.

        Args:
        ----------
            generated_sql: SQL query to validate
            rules: List of validation rule strings

        Returns:
        ----------
            Dictionary mapping rule names to validation results

        Example:
        ----------
            >>> validator = SQLValidator()
            >>> sql = "SELECT * FROM products WHERE price > 100"
            >>> rules = ["has_where_clause", "uses_comparison"]
            >>> results = validator.check_validation_rules(sql, rules)
        """
        results: dict[str, bool] = {}
        sql_upper = generated_sql.upper()

        for rule in rules:
            if rule == "has_where_clause":
                results[rule] = "WHERE" in sql_upper
            elif rule == "has_order_by":
                results[rule] = "ORDER BY" in sql_upper
            elif rule == "has_limit":
                results[rule] = "LIMIT" in sql_upper
            elif rule == "has_group_by":
                results[rule] = "GROUP BY" in sql_upper
            elif rule == "has_join":
                results[rule] = "JOIN" in sql_upper
            elif rule == "uses_aggregate":
                agg_funcs = ["COUNT", "SUM", "AVG", "MAX", "MIN"]
                results[rule] = any(func in sql_upper for func in agg_funcs)
            else:
                results[rule] = True  # Unknown rules default to pass

        return results


class TestReport:
    """
    Generates and manages test execution reports.

    This class aggregates test results and generates formatted
    reports in various formats (text, JSON, HTML).
    """

    def __init__(self) -> None:
        """Initialize test report."""
        self.results: list[TestResult] = []
        self.start_time: float | None = None
        self.end_time: float | None = None

    def add_result(self, result: TestResult) -> None:
        """
        Add a test result to the report.

        Args:
        ----------
            result: Test result to add

        Example:
        ----------
            >>> report = TestReport()
            >>> result = TestResult(test_id="L1.1", status=TestStatus.PASSED)
            >>> report.add_result(result)
        """
        self.results.append(result)

    def get_summary(self) -> dict[str, Any]:
        """
        Get test execution summary statistics.

        Returns:
        ----------
            Dictionary containing summary statistics

        Example:
        ----------
            >>> report = TestReport()
            >>> # ... add results ...
            >>> summary = report.get_summary()
            >>> print(summary["total"])
        """
        total = len(self.results)
        passed = sum(1 for r in self.results if r.status == TestStatus.PASSED)
        failed = sum(1 for r in self.results if r.status == TestStatus.FAILED)
        skipped = sum(1 for r in self.results if r.status == TestStatus.SKIPPED)

        return {
            "total": total,
            "passed": passed,
            "failed": failed,
            "skipped": skipped,
            "pass_rate": (passed / total * 100) if total > 0 else 0.0,
        }

    def format_text(self) -> str:
        """
        Format report as plain text.

        Returns:
        ----------
            Formatted text report

        Example:
        ----------
            >>> report = TestReport()
            >>> # ... add results ...
            >>> print(report.format_text())
        """
        summary = self.get_summary()
        lines = [
            "=" * 60,
            "PostgreSQL MCP Test Report",
            "=" * 60,
            "",
            f"Total Tests: {summary['total']}",
            f"Passed: {summary['passed']} ({summary['pass_rate']:.1f}%)",
            f"Failed: {summary['failed']}",
            f"Skipped: {summary['skipped']}",
            "",
        ]

        # Group by category
        by_category: dict[TestCategory, list[TestResult]] = {}
        for result in self.results:
            # Map test ID prefix to category enum
            prefix = result.test_id.split(".")[0]
            category_map = {
                "L1": TestCategory.L1_BASIC,
                "L2": TestCategory.L2_JOIN,
                "L3": TestCategory.L3_AGGREGATE,
                "L4": TestCategory.L4_COMPLEX,
                "L5": TestCategory.L5_ADVANCED,
                "S1": TestCategory.S1_SECURITY,
            }
            cat = category_map.get(prefix)
            if cat is None:
                continue  # Skip unknown categories
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(result)

        for category, cat_results in sorted(by_category.items()):
            lines.append(f"\n{category.value}:")
            lines.append("-" * 60)
            for result in cat_results:
                status_symbol = "✓" if result.status == TestStatus.PASSED else "✗"
                lines.append(f"  {status_symbol} {result.test_id}: {result.status.value}")
                if result.error_message:
                    lines.append(f"    Error: {result.error_message}")

        return "\n".join(lines)
